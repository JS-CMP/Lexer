#include <gtest/gtest.h>
#include <filesystem>
#include <fstream>
#include "../include/Tokenizer/Lexer.hpp"
#include "../include/AST/Parser.hpp"
#include "../include/Program.hpp"
#include "Optimization/Optimizer.hpp"

#include <cstdlib>

namespace fs = std::filesystem;

std::string readFile(const std::string& filePath) {
    std::ifstream fileStream(filePath);
    std::stringstream buffer;
    buffer << fileStream.rdbuf();
    return buffer.str();
}

void writeFile(const std::string& filePath, const std::string& content) {
    std::ofstream fileStream(filePath);
    fileStream << content;
}

TEST(AutoGeneratedTests /*unused*/, AllCases /*unused*/) {
    std::string baseDir = "../tests/cases/basic";

    for (const auto& entry : fs::recursive_directory_iterator(baseDir)) {
        if (entry.path().extension() == ".js") {
            std::string js_path = entry.path().string();
            std::filesystem::path cpp_path = entry.path();
            cpp_path.replace_extension(".out");
            std::filesystem::path out_path = entry.path();
            out_path.replace_extension(".tmp");

            if (fs::exists(cpp_path)) {
                std::string input = readFile(js_path);
                std::string expected_output = readFile(cpp_path);
                Lexer::Lexer lexer(input);
                std::vector<Lexer::Token> tokens = lexer.tokenize();

                Lexer::AST::Parser parser(tokens);
                std::vector<Lexer::AST::Stmt::Ptr> ast;
                try {
                    while (!parser.isAtEnd()) {
                        auto stmt = parser.parseStatement();
                        stmt->print(0);
                        ast.push_back(std::move(stmt));
                    }
                } catch (const std::exception& e) {
                    std::cerr << "\033[1;31mError: " << e.what() << "\033[0m\n";
                }

                std::string program_output;
                try {
                    Lexer::Opt::Optimizer optimizer(ast);
                    program_output = optimizer.transpile();
                    std::cout << program_output << std::endl;
                } catch (const std::exception& e) {
                    std::cerr << "\033[1;31mError: " << e.what() << "\033[0m\n";
                    program_output = "// not handle by the lexer for now\n"
                                     "#include <iostream>\n"
                                     "int main() {std::cerr << \"somethings was not handle\" << std::endl; return 0;}";
                }
                // Lexer::Program program(tokens);
                // program.parse();
                //
                //
                writeFile(out_path, program_output);
                EXPECT_EQ(program_output, expected_output)
                           << "Output mismatch for " << js_path << ". Check " << cpp_path;

                std::cout << std::string(10, '-') << " JAVASCRIPT CODE " << std::string(10, '-') << std::endl;
                std::cout << input << std::endl;
                std::cout << std::string(10, '-') << " GENERATED AST " << std::string(10, '-') << std::endl;
                for (const auto& stmt : ast) {
                    stmt->print(0);
                }
                std::cout << std::string(10, '-') << " GENERATED CODE " << std::string(10, '-') << std::endl;
                std::cout << program_output << std::endl;

            } else {
                FAIL() << "Missing expected output file for " << js_path << ": " << cpp_path;
            }
        }
    }
}
